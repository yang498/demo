'use strict';

var month30 = [4, 6, 9, 11];
var month31 = [1, 3, 5, 7, 8, 10, 12];
var week = ['日', '一', '二', '三', '四', '五', '六'];
var nowMonth = 0;
var dataNameE = [];
var dataNameS = [];
var dataNameW = [];
var dataNameN = [];
var dataNameA = [];
var dataNameF = [];
for (var i = 1; i <= data.lastMonth; i++) {
	dataNameE.push('east' + i);
	dataNameS.push('south' + i);
	dataNameW.push('west' + i);
	dataNameN.push('north' + i);
	dataNameA.push('allFriend' + i);
	dataNameF.push('fail' + i);
}
for (var _i = 0; _i < 32; _i++) {
	// 如果这一天的数据不存在则跳过到下个月
	if (!data[dataNameE[nowMonth]][_i]) {
		if (nowMonth === dataNameE.length - 1) break; // 如果又是最后一个月则终止循环
		_i = -1;
		nowMonth++;
		continue;
	}
	data.east.push(data[dataNameE[nowMonth]][_i]); // 如果只有东push了字符串那就多一天，在建立xDate的时候删掉
	if (!isNaN(data[dataNameE[nowMonth]][_i])) {
		// 如果这一天是个字符串则跳过这天
		data.south.push(data[dataNameS[nowMonth]][_i]);
		data.west.push(data[dataNameW[nowMonth]][_i]);
		data.north.push(data[dataNameN[nowMonth]][_i]);
		data.allFriend.push(data[dataNameA[nowMonth]][_i]);
		data.fail.push(data[dataNameF[nowMonth]][_i]);
		data.all.push(data[dataNameE[nowMonth]][_i] + data[dataNameS[nowMonth]][_i] + data[dataNameW[nowMonth]][_i] + data[dataNameN[nowMonth]][_i]);
	}
}
// 建立折线图x轴的日期，初始为data的起始日期
var xDate = [data.startDate.slice(5)];
var month = data.startDate[5] - 0; // 起始月份，1月是个字符串
var today = data.startDate.slice(-2); // 日期
var day = data.all.length - 1; // 所有天数，标题会用到
for (var _i2 = 1; _i2 <= day; _i2++) {	// 从1开始在日期是字符串的时候有用，会差一位
	if (month31.indexOf(month) > -1 && today > 30 || month30.indexOf(month) > -1 && today > 29 || month == 2 && today > 27) {
		month++;
		today = 0;
	}
	today = isNaN(data.east[_i2]) ? data.east[_i2].replace(/\d*,/, '') : today - 0 + 1; // 如果这一天是个字符串则跳到指定的逗号后面的天数，否则就++
	xDate.push(month + '/' + today);
}
// 2/2号开始建立南北2区，加上1区人数，如果再建立3区再加上2区人数----------------------------------------
for (var _i3 = data.east1.length + 1; _i3 < data.east.length; _i3++) {
	data.south[_i3] += data.lastSouth1;
	data.north[_i3] += data.lastNorth1;
	data.all[_i3] += data.lastSouth1 + data.lastNorth1;
}

// excel数据--------------------------------------------------------------------------------------------------------------------
var excelPro = []; // 省份，用于判断name，不存在就创建，存在就+1
var excelCity = []; // 城市
var excelKind = []; // 公司性质
var excelPost = []; // 职位
var excelProData = []; // 省份和对应的值
var excelCityData = []; // 城市和对应的值
var excelKindData = []; // 公司性质和对应的值
var excelPostData = []; // 职位和对应的值
excel.split('\n').forEach(function (item, index) {
	var res = item.split(',');
	if (res[0] && res[1] && res[3] && res[5]) {
		// 省
		if (excelPro.indexOf(res[0]) < 0) {
			excelPro.push(res[0]);
			excelProData.push({ name: res[0], value: 1 });
		} else {
			excelProData[excelPro.indexOf(res[0])].value++;
		}
		// 市
		var city = /北京|天津|上海|重庆/.test(res[0]) ? res[0] : res[1]
		if(excelCity.indexOf(city) < 0){
			excelCity.push(city)
			excelCityData.push({name:city,value:1})
		} else {
			excelCityData[excelCity.indexOf(city)].value++
		}
		// 公司性质
		if (excelKind.indexOf(res[3]) < 0) {
			excelKind.push(res[3]);
			excelKindData.push({ name: res[3], value: 1 });
		} else {
			excelKindData[excelKind.indexOf(res[3])].value++;
		}
		// 职位
		if (excelPost.indexOf(res[5]) < 0) {
			excelPost.push(res[5]);
			excelPostData.push({ name: res[5], value: 1 });
		} else {
			excelPostData[excelPost.indexOf(res[5])].value++;
		}
	}
});
// 数据合并为每项格式为{name:'城市',value:[lng经度, lat纬度, value]}
var mapCityLngLatVal = [];
for (var _iterator = excelProData, _isArray = Array.isArray(_iterator), _i4 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
	var _ref;

	if (_isArray) {
		if (_i4 >= _iterator.length) break;
		_ref = _iterator[_i4++];
	} else {
		_i4 = _iterator.next();
		if (_i4.done) break;
		_ref = _i4.value;
	}

	var item = _ref;
	/北京|天津|上海|重庆/.test(item.name) && mapCityLngLatVal.push({ name: item.name, value: mapCityLngLat[item.name].concat(item.value) });
}for (var _iterator2 = excelCityData, _isArray2 = Array.isArray(_iterator2), _i5 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
	var _ref2;

	if (_isArray2) {
		if (_i5 >= _iterator2.length) break;
		_ref2 = _iterator2[_i5++];
	} else {
		_i5 = _iterator2.next();
		if (_i5.done) break;
		_ref2 = _i5.value;
	}

	var _item = _ref2;
	mapCityLngLat[_item.name] && mapCityLngLatVal.push({ name: _item.name, value: mapCityLngLat[_item.name].concat(_item.value) });
} // 各数据排序
excelProData.sort(function (a, b) {
	return b.value - a.value;
});
excelCityData.sort(function (a, b) {
	return b.value - a.value;
});
excelKindData.sort(function (a, b) {
	return b.value - a.value;
});
excelPostData.sort(function (a, b) {
	return b.value - a.value;
});
// 省市柱形图需要的X轴数据
var excelProName = [];
var excelCityName = [];
for (var _iterator3 = excelProData, _isArray3 = Array.isArray(_iterator3), _i6 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
	var _ref3;

	if (_isArray3) {
		if (_i6 >= _iterator3.length) break;
		_ref3 = _iterator3[_i6++];
	} else {
		_i6 = _iterator3.next();
		if (_i6.done) break;
		_ref3 = _i6.value;
	}

	var _item2 = _ref3;
	excelProName.push(_item2.name);
}for (var _iterator4 = excelCityData, _isArray4 = Array.isArray(_iterator4), _i7 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
	var _ref4;

	if (_isArray4) {
		if (_i7 >= _iterator4.length) break;
		_ref4 = _iterator4[_i7++];
	} else {
		_i7 = _iterator4.next();
		if (_i7.done) break;
		_ref4 = _i7.value;
	}

	var _item3 = _ref4;
	excelCityName.push(_item3.name);
} // 省人数柱形图分东南西北，青海和西藏暂时没人
var proEast = ['安徽', '江苏', '上海', '浙江'];
var proSouth = ['福建', '广东', '广西', '海南', '湖南', '江西'];
var proWest = ['重庆', '甘肃', '贵州', '湖北', '宁夏', '青海', '陕西', '四川', '新疆', '西藏', '云南'];
var proNorth = ['北京', '河北', '河南', '黑龙江', '吉林', '辽宁', '内蒙古', '山东', '山西', '天津'];
var proEastData = [];
var proSouthData = [];
var proWestData = [];
var proNorthData = [];
for (var _iterator5 = excelProData, _isArray5 = Array.isArray(_iterator5), _i8 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
	var _ref5;

	if (_isArray5) {
		if (_i8 >= _iterator5.length) break;
		_ref5 = _iterator5[_i8++];
	} else {
		_i8 = _iterator5.next();
		if (_i8.done) break;
		_ref5 = _i8.value;
	}

	var _item4 = _ref5;

	proEastData.push(proEast.indexOf(_item4.name) < 0 ? { name: _item4.name } : _item4);
	proSouthData.push(proSouth.indexOf(_item4.name) < 0 ? { name: _item4.name } : _item4);
	proWestData.push(proWest.indexOf(_item4.name) < 0 ? { name: _item4.name } : _item4);
	proNorthData.push(proNorth.indexOf(_item4.name) < 0 ? { name: _item4.name } : _item4);
}
// 职位饼图低于5个人就人数相同的合在一起
var excelPostFirst = [];
var excelPostIndex = 1; // 每10个换行
for (var _i9 = 0; _i9 < excelPostData.length; _i9++) {
	if (excelPostData[_i9].value < 5) {
		// 给第一次匹配到的存起来，excelPostData[i].value就是index，i就是value
		// 之后的把name和value放到第一次匹配的里面，用逗号隔开，并把这个元素删掉
		if (excelPostFirst[excelPostData[_i9].value - 1]) {
			var nameSplit = '、';
			if (excelPostData[_i9].value === 1 || excelPostData[_i9].value === 2) {
				excelPostIndex === 8 ? excelPostIndex = 1 : excelPostIndex++;
				excelPostIndex === 8 && (nameSplit = '\n');
			}
			excelPostData[excelPostFirst[excelPostData[_i9].value - 1]].name += nameSplit + excelPostData[_i9].name;
			excelPostData[excelPostFirst[excelPostData[_i9].value - 1]].value += excelPostData[_i9].value;
			excelPostData.splice(_i9, 1);
			_i9--;
		} else {
			excelPostFirst[excelPostData[_i9].value - 1] = _i9;
			excelPostData[_i9].name = (excelPostData[_i9].value === 1 ? '\n\n\n' : '') + excelPostData[_i9].value + '人集合：' + excelPostData[_i9].name;
		}
	}
}